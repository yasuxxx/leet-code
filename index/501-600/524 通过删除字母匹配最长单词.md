总的思路是贪心+匹配
1. 将s中的字符串和自身的位置存入hashMap(key是字母，value是一个列表)
2. 将dictionary排序（长的在前，长度一样的，字典序小的在前）
3. dictionary从前往后拿单词，去hashMap找是否有这个串，有则即答案
```java
  class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        Collections.sort(dictionary,(a,b)->{
            if(a.length()!=b.length()) return b.length()-a.length();
            else return a.compareTo(b);
        });
        Map<Character,List<Integer>> map = new HashMap();
        char[] ch = s.toCharArray();
        for(int i = 0;i<ch.length;i++){
            List<Integer> indexL = map.getOrDefault(ch[i],new ArrayList<Integer>());
            indexL.add(i);
            map.put(ch[i],indexL);
        }
        for(String ss:dictionary){
            char[] chs = ss.toCharArray();
            int flag = 1;
            int pre = -1;
            for(char c:chs){
                if(!map.containsKey(c)){
                    flag = -1;
                    break;
                }
                List<Integer> list = map.get(c);
                int i = 0;
                for(;i<list.size();i++){
                    if(list.get(i)>pre){
                        //System.out.println(list.get(i)+" "+pre+" "+c);
                        pre = list.get(i);
                        break;
                    }
                }
                if(i==list.size()&&list.get(i-1)<=pre){
                    flag = -1;break;
                }
            }
            if(flag==-1) continue;
            if(flag==1) return ss;
        }
        return "";
    }
}
```